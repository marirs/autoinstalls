# PostgreSQL Security Configuration
# Security best practices and hardening for PostgreSQL

# Authentication security
# Add to postgresql.conf:

# Password encryption
password_encryption = scram-sha-256

# Connection security
listen_addresses = '127.0.0.1'          # Bind to localhost only for security
port = 5432

# SSL/TLS configuration
ssl = on                                # Enable SSL
ssl_cert_file = 'server.crt'            # SSL certificate file
ssl_key_file = 'server.key'             # SSL private key file
ssl_ca_file = 'root.crt'                # SSL CA certificate
ssl_crl_file = 'root.crl'               # SSL certificate revocation list
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'  # SSL cipher suites
ssl_prefer_server_ciphers = on          # Prefer server ciphers
ssl_ecdh_curve = 'prime256v1'           # ECDH curve
ssl_min_protocol_version = 'TLSv1.2'    # Minimum TLS version
ssl_max_protocol_version = 'TLSv1.3'    # Maximum TLS version

# Logging security
log_connections = on                     # Log all connections
log_disconnections = on                  # Log all disconnections
log_hostname = on                        # Log hostnames in connections
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '  # Detailed log prefix

# Security settings
check_function_bodies = on               # Check function bodies during CREATE FUNCTION
default_transaction_isolation = 'read committed'  # Default transaction isolation
default_transaction_read_only = off      # Default transaction read-only
default_transaction_deferrable = off     # Default transaction deferrable

# Row Level Security
row_security = on                       # Enable row level security

# Security roles and permissions:

# 1. Create security roles
-- Superuser role (limited use)
CREATE ROLE dba_admin WITH SUPERUSER NOINHERIT LOGIN PASSWORD 'strong_password_here';

-- Application admin role
CREATE ROLE app_admin WITH CREATEDB CREATEROLE NOINHERIT LOGIN PASSWORD 'app_admin_password';

-- Application user role
CREATE ROLE app_user NOINHERIT LOGIN PASSWORD 'app_user_password';

-- Read-only role
CREATE ROLE read_only NOINHERIT LOGIN PASSWORD 'read_only_password';

-- Backup role
CREATE ROLE backup_user WITH REPLICATION NOINHERIT LOGIN PASSWORD 'backup_password';

# 2. Grant role memberships
GRANT app_user TO app_admin;
GRANT read_only TO app_user;

# 3. Database-level security
-- Create database with owner
CREATE DATABASE myapp OWNER app_admin;

-- Connect to database and set up schema security
\c myapp

-- Grant schema privileges
GRANT USAGE ON SCHEMA public TO app_user;
GRANT CREATE ON SCHEMA public TO app_admin;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO app_admin;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO app_admin;

-- Set default privileges for future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO app_admin;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO app_admin;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO read_only;

# 4. Table-level security
-- Example table with RLS
CREATE TABLE sensitive_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    data TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Enable Row Level Security
ALTER TABLE sensitive_data ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY user_data_policy ON sensitive_data
    FOR ALL
    TO app_user
    USING (user_id = current_setting('app.current_user_id')::integer);

CREATE POLICY read_only_policy ON sensitive_data
    FOR SELECT
    TO read_only
    USING (true);

# 5. Column-level security
-- Create view with limited columns
CREATE VIEW public_data AS
SELECT id, created_at FROM sensitive_data;

-- Grant view access
GRANT SELECT ON public_data TO read_only;

# 6. Function security
-- Create secure function
CREATE OR REPLACE FUNCTION get_user_data(p_user_id INTEGER)
RETURNS TABLE(id INTEGER, data TEXT)
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT id, data
    FROM sensitive_data
    WHERE user_id = p_user_id;
END;
$$;

-- Grant function access
GRANT EXECUTE ON FUNCTION get_user_data(INTEGER) TO app_user;

# 7. Audit logging
-- Create audit table
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL,
    user_name TEXT NOT NULL,
    old_values JSONB,
    new_values JSONB,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create audit trigger function
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER
SECURITY DEFINER
LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, user_name, new_values)
        VALUES (TG_TABLE_NAME, TG_OP, current_user, row_to_json(NEW));
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, user_name, old_values, new_values)
        VALUES (TG_TABLE_NAME, TG_OP, current_user, row_to_json(OLD), row_to_json(NEW));
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, user_name, old_values)
        VALUES (TG_TABLE_NAME, TG_OP, current_user, row_to_json(OLD));
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$;

-- Apply audit trigger
CREATE TRIGGER sensitive_data_audit
    AFTER INSERT OR UPDATE OR DELETE ON sensitive_data
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

# 8. Security monitoring queries

-- Check for weak passwords
SELECT usename, passwduntil 
FROM pg_user 
WHERE passwduntil IS NULL OR passwduntil < CURRENT_TIMESTAMP;

-- Check for excessive privileges
SELECT 
    usename,
    usesuper,
    usecreatedb,
    userepl,
    usebypassrls
FROM pg_user 
WHERE usesuper = true OR usecreatedb = true;

-- Check for unused accounts
SELECT 
    usename,
    (SELECT MAX(backend_start) 
     FROM pg_stat_activity 
     WHERE usename = pg_user.usename) AS last_login
FROM pg_user 
WHERE usename NOT IN ('postgres', 'replicator');

-- Check for open connections
SELECT 
    datname,
    usename,
    client_addr,
    state,
    query_start,
    query
FROM pg_stat_activity 
WHERE state != 'idle';

# 9. Security best practices:

# Network Security:
# - Use firewall to restrict access to PostgreSQL port (5432)
# - Use VPN or SSH tunnel for remote access
# - Implement IP whitelisting in pg_hba.conf
# - Use SSL/TLS for all connections

# Authentication Security:
# - Use strong passwords and regular rotation
# - Implement multi-factor authentication where possible
# - Use SCRAM-SHA-256 password encryption
# - Limit superuser access

# Data Security:
# - Enable Row Level Security (RLS) for sensitive data
# - Use views to limit data exposure
# - Implement column-level encryption for sensitive fields
# - Regular security audits and penetration testing

# Operational Security:
# - Regular backup and restore testing
# - Implement audit logging for all sensitive operations
# - Use connection pooling with proper authentication
# - Monitor for unusual activity patterns

# Example secure pg_hba.conf entries (localhost only):

# Local connections with peer authentication
local   all             postgres                                peer

# Local connections with password authentication
local   all             all                                     md5

# IPv4 localhost connections with SSL
hostssl all             all             127.0.0.1/32            md5

# IPv6 localhost connections with SSL
hostssl all             all             ::1/128                 md5

# Reject all other connections for security
host    all             all             0.0.0.0/0               reject
host    all             all             ::/0                    reject

# Replication connections (localhost only)
hostssl replication     replicator      127.0.0.1/32            md5
hostssl replication     replicator      ::1/128                 md5

# 10. Security monitoring script
# Save as security-check.sh

#!/bin/bash
POSTGRES_USER="postgres"
POSTGRES_HOST="localhost"
POSTGRES_PORT="5432"

echo "=== PostgreSQL Security Check ==="

# Check for weak passwords
echo "Checking for weak passwords..."
psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d postgres -c "
SELECT 
    usename,
    CASE 
        WHEN passwduntil IS NULL THEN 'No password expiry'
        WHEN passwduntil < CURRENT_TIMESTAMP THEN 'Password expired'
        ELSE 'Password valid'
    END AS password_status
FROM pg_user 
WHERE usename NOT IN ('postgres');" --quiet

# Check for excessive privileges
echo -e "\nChecking for excessive privileges..."
psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d postgres -c "
SELECT 
    usename,
    usesuper as superuser,
    usecreatedb as create_db,
    userepl as replication,
    usebypassrls as bypass_rls
FROM pg_user 
WHERE usesuper = true OR usecreatedb = true;" --quiet

# Check for unused accounts
echo -e "\nChecking for unused accounts..."
psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d postgres -c "
SELECT 
    usename,
    COALESCE(MAX(backend_start), 'Never') AS last_login
FROM pg_user 
LEFT JOIN pg_stat_activity ON usename = pg_user.usename
WHERE usename NOT IN ('postgres', 'replicator')
GROUP BY usename
HAVING MAX(backend_start) < CURRENT_TIMESTAMP - INTERVAL '30 days'
   OR MAX(backend_start) IS NULL;" --quiet

# Check for open connections
echo -e "\nCurrent active connections..."
psql -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER -d postgres -c "
SELECT 
    datname,
    usename,
    client_addr,
    state,
    COUNT(*) AS connection_count
FROM pg_stat_activity 
WHERE state != 'idle'
GROUP BY datname, usename, client_addr, state;" --quiet
